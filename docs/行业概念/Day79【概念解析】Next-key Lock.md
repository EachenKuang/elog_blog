---
password: ""
icon: ""
date: "2023-12-09"
type: Post
category: 行业概念
slug: industry-day79
tags:
  - 行业概念
  - 文字
  - 思考
  - MySQL
summary: ""
title: Day79【概念解析】Next-key Lock
status: Published
urlname: 06d5189c-b49b-47ca-a000-b58401fdb847
updated: "2023-12-14 01:48:00"
---

# 整理定义

**临键锁（Next-key Lock）**= Gap Lock + Record Lock

临键锁是索引记录上的**记录锁**和索引记录之前的间隙上的**间隙锁**的组合。

# 复述展开

InnoDB 以这样的方式执行行级锁定：**当它搜索或扫描表索引时，它会在遇到的索引记录上设置共享锁（S 锁）或排他锁（X 锁）**。 因此，行级锁实际上是索引记录锁。 索引记录上的**临键锁**也会影响该索引记录之前的“间隙”。 也就是说，**临键锁**是索引记录锁加上索引记录之前间隙上的间隙锁。 如果一个会话对索引中的记录 R 具有共享锁或独占锁，则另一个会话无法在索引顺序中紧邻 R 之前的间隙中插入新索引记录。

假设索引包含值 10、11、13 和 20。该索引可能的**临键锁**涵盖以下区间，其中圆括号表示排除区间端点，方括号表示包含端点：

```sql
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

对于最后一个间隔，**临键锁**锁定索引中最大值和“**supremum**”伪记录的值高于索引中的任何值。上确界不是一个真正的索引记录，因此，实际上，这个下一个键锁只锁定最大索引值后面的间隙。
InnoDB 的默认事务隔离级别为 **可重复读（Repeated Read）**。在这种情况下，InnoDB 使用**临键锁**进行搜索和索引扫描，这可以防止**幻读**。

> 也可以理解为一种特殊的**间隙锁**。通过**临建锁**可以解决`幻读`的问题。 每个数据行上的**非唯一索引列**上都会存在一把**临键锁**，当某个事务持有该数据行的**临键锁**时，会锁住一段**左开右闭区间**的数据。需要强调的一点是，InnoDB 中**行级锁**是基于索引实现的，**临键锁**只与**非唯一索引列**有关，在`唯一索引列（包括主键列）上不存在临键锁`。

    ——[MySQL记录锁、间隙锁、临键锁（Next-Key Locks）详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/435113954)

|     | 事务 A                                             | 事务 B                                         |
| --- | -------------------------------------------------- | ---------------------------------------------- |
| T1  | `UPDATE table SET name = Vladimir WHERE age = 14;` |                                                |
| T2  |                                                    | `INSERT INTO table VALUES(100, 19, 'tianqi');` |
| T3  | commit                                             |                                                |
| T3  |                                                    | commit                                         |

T2 会因为 T1 对 age 为 19 的列进行锁定后，将（14，20]的区间进行了锁定

很明显，事务 A 在对 age 为 24 的列进行 UPDATE 操作的同时，也获取了（14，20] 这个区间内的临键锁。

> 【[funnylog.gitee.io/mysql45/21 讲为什么我只改一行的语句，锁这么多.html](https://funnylog.gitee.io/mysql45/21%E8%AE%B2%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E5%8F%AA%E6%94%B9%E4%B8%80%E8%A1%8C%E7%9A%84%E8%AF%AD%E5%8F%A5%EF%BC%8C%E9%94%81%E8%BF%99%E4%B9%88%E5%A4%9A.html)】

    首先说明一下，这些加锁规则我没在别的地方看到过有类似的总结，以前我自己判断的时候都是想着代码里面的实现来脑补的。这次为了总结成不看代码的同学也能理解的规则，是我又重新刷了代码临时总结出来的。所以，**这个规则有以下两条前提说明：**

    1. MySQL后面的版本可能会改变加锁策略，所以这个规则只限于截止到现在的最新版本，即5.x系列<=5.7.24，8.0系列 <=8.0.13。
    2. 如果大家在验证中有发现bad case的话，请提出来，我会再补充进这篇文章，使得一起学习本专栏的所有同学都能受益。

    因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。


    **我总结的加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。**

    1. 原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。
    2. 原则2：查找过程中访问到的对象才会加锁。
    3. 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
    4. 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。
    5. 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。

# 理解体会

这里对  **记录锁**、**间隙锁**、**临键锁**  做一个总结

- **InnoDB**  中的**行锁**的实现依赖于**索引**，一旦某个加锁操作没有使用到索引，那么该锁就会退化为`表锁`。
- **记录锁**存在于包括**主键索引**在内的**唯一索引**中，锁定单条索引记录。
- **临键锁**存在于**非唯一索引**中，锁定**开区间**范围内的一段间隔，它是基于**间隙锁**实现的。
